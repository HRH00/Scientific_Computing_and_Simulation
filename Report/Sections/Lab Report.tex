\chapter{Lab Report}
This report section will explore the lab work completed throughout the module and discuss skills learned through reflections on each lab. Evidence that each task has been completed is provided.

\section{Lab 1 Naive Fourier Transform}

    The first lab comprised of performing a naive discrete Fourier Transform (DFT) and Inverse DFT on a .pgm image file. The Fourier analysis allows for different filters to be applied to the Image. The original image is shown in Figure \autoref{fig:wolf_image}

    \begin{figure}[H]
        \centering
            \includegraphics[width=0.49\columnwidth]{Figures/Week 1/W1-Wolf-Original.png}
            \caption{A screenshot of the original wolf image}
            \label{fig:wolf_image}
    \end{figure}
    
    A Fourier analysis is a mathematical technique which decomposes a waveform into its fundamental sinusoidal sub-components, allowing for the waveform to be represented in the frequency domain, as opposed to the spatial domain. These Fourier components represent the frequency, amplitude and phase which make up the original signal. By doing this, Fourier analysis allows image processing (among other signal processes) to be performed. The sum of the sub-components is used to recreate the original waveform. 
    

    To begin, supporting Java classes were provided, they are: 
    \begin{itemize}
        \item DisplayDensity.java
        \item ReadPGM.java
        \item Display2dFT.java
        \item SimpleFT.java
    \end{itemize}
        
    'DisplayDensity.java' displays a greyscale image rendered from a 2D array of image data, with smaller values displayed as dark and larger values as light.
    
    'ReadPGM.java' parses the .pgm file for use in the skeleton program and 'Display2dFT.java' allows the Fourier Transform (FT) output to be represented graphically, using colour to represent imaginary number components. 'SimpleFT' is a skeleton program to code in.
    

    
    \subsection{Discrete Fourier Transform}
    To perform the DFT, the equation shown in \autoref{fig:equation-FT} must be implemented, C is a 2D array of length N.
    
    \begin{center}
        \begin{equation}
            C_{kl} = 1/N^2 \sum_{m=0}^{N-1} \sum_{n=0}^{N-1}\ X_{mn} . e^{-2\pi i(km+nl)/N}
            \label{fig:equation-FT}
        \end{equation}  
    \end{center}%Equation

    Implementation of the equation is shown in \autoref{fig:wolf-FT-code}. An array called 'X' stored the original .pgm data. The program decomposes the original frequencies into two arrays, this is because the process generates complex numbers. The imaginary component of the complex number is stored in 'CIm' while the real component is stored in 'CRe'. 
 
    \begin{figure}[H]
        \centering
        \includegraphics[width=1\columnwidth]{Figures/Week 1/W1-SimpleFT-Completed-For-Loop.png}
        \caption{A screenshot of the implementation of the Fourier Transform}
        \label{fig:wolf-FT-code}
    \end{figure}

    The graphical representation of the Fourier Analysis is shown in \autoref{fig:wolf-DFT}. The 'Display2dFT' class has been used to implement this, the colour of each pixel represents the imaginary component.
    
    \begin{figure}[H]
        \centering
        \includegraphics[width=0.49\columnwidth]{Figures/Week 1/W1-FT.png}
        \caption{A screenshot of the Discrete Fourier Transform graphical output}
        \label{fig:wolf-DFT}
    \end{figure}
    
    
    \subsection{Inverse Discrete Fourier Transform}
    The Inverse function is used to reconstruct the image from the frequency domain representation, by converting it back to a spatial domain. The equation \autoref{fig:equation-InverseFT} must be implemented to do this. 

    \begin{center}
        \begin{equation}
            X_{mn} = \sum_{k=0}^{N-1} \sum_{l=0}^{N-1}\ C_{kl} . e^{2\pi i(km+nl)/N}
            \label{fig:equation-InverseFT}
        \end{equation}  
        \end{center}
        
    The code of the implementation is shown in \autoref{fig:inverse-DFT-Code}. The reconstructed image array is called 'reconstructed'.  
    In this code, pixel value normalisation must be performed to set each pixel to a value which the 'DisplayDensity' class can output correctly. 
        
        \begin{figure}[H]
            \centering
            \includegraphics[width=0.9\columnwidth]{Figures/Week 1/W1-SimpleFT-InverseDFT-Implementation.png}
            \caption{A screenshot of the Java inverse DFT implementation}
            \label{fig:inverse-DFT-Code}
    \end{figure}

    All the graphical outputs of the program are shown in \autoref{fig:inverse-DFT-Images-Output}, the reconstructed image is on the right side. 
    
    \begin{figure}[H]
            \centering
            \includegraphics[width=0.8\columnwidth]{Figures/Week 1/W1-SimpleFT-InverseDFT-Graphical-Outputs.png}
            \caption{Graphical output of the program - inverse DFT reconstruction on the right side}
            \label{fig:inverse-DFT-Images-Output}
    \end{figure}

    While the outputted images are the same as the 'DisplayDensity' class essentially rounds values, the values in the new 'reconstructed' array deviate from the original 'X' array. This is due to the primitive double datatype in Java being a floating-point representation, causing some precision to be lost during calculations - this is called a floating-point error.
    
    \autoref{fig:Testing-Code} and \autoref{fig:Testing-Code-output} show the code and console output for detecting incorrectly reconstructed values. The 'reconstructed' values are close to the original.   
    
    \begin{figure}[H]
        \centering
        \includegraphics[width=1\columnwidth]{Figures/Week 1/W1-SimpleFT-InverseDFT-Test-1.0-code.png}
        \caption{A screenshot of the testing code}
        \label{fig:Testing-Code}
    \end{figure}
    \begin{figure}[H]
            \centering
            \includegraphics[width=.49\columnwidth]{Figures/Week 1/W1-SimpleFT-InverseDFT-Test-1.0-Output.png}
            \caption{A screenshot of the testing code output}
            \label{fig:Testing-Code-output}
        \end{figure}

    \autoref{fig:floating-Point-Fix}, \autoref{fig:floating-Point-Fixed-test} and \autoref{fig:floating-Point-Fixed-CLI-Output} show that in this instance, the error can be completely removed simply by rounding the reconstructed value to the nearest integer.
    \newpage
    \begin{figure}[H]
        \centering
        \includegraphics[width=1\columnwidth]{Figures/Week 1/W1-SimpleFT-InverseDFT-Floating-Point-Fix.png}
        \caption{A screenshot of code to fix floating point error}
        \label{fig:floating-Point-Fix}
    \end{figure}
    \begin{figure}[H]
            \centering
            \includegraphics[width=1\columnwidth]{Figures/Week 1/W1-SimpleFT-InverseDFT-Test-2.0-code.png}
            \caption{A screenshot of code to test the floating point error fix}
            \label{fig:floating-Point-Fixed-test}
        \end{figure}   
    \begin{figure}[H]
            \centering
            \includegraphics[width=0.8\columnwidth]{Figures/Week 1/W1-SimpleFT-InverseDFT-Test-2.0-CLI-Output.png}
            \caption{A screenshot of console output showing floating point error test has passed}
            \label{fig:floating-Point-Fixed-CLI-Output}
        \end{figure}
        
   
    \newpage
    \subsection{Filtering}
    Now that the data is in the frequency domain, performing filtering operations is simple. 
    
    \subsubsection{Low Pass Filter}
    A low pass filter removes frequencies above a cutoff value allowing low frequencies to pass through. In this instance, the cutoff was set to $N/8$ or $256/8$. \autoref{fig:Low-Pass-Filter-code} show that any values greater than the cutoff are set to $0$. The absolute value of each input value is used to remove the sign from the number, allowing the conditional statements to function correctly. 
    
    \begin{figure}[H]
        \centering
        \includegraphics[width=0.8\columnwidth]{Figures/Week 1/W1-Low-Pass-Code.png}
        \caption{Screenshot of FT low pass filter code}
        \label{fig:Low-Pass-Filter-code}
      \end{figure}

    \autoref{fig:Low-Pass-Filter-Truncated} shows the truncated FT graphic, note the large black area which represents the removed frequencies. In \autoref{fig:Low-Pass-Filter-Image}, a lot of detail is clearly missing from the image.
    \begin{figure}[H]
        \centering
        \includegraphics[width=0.49\columnwidth]{Figures/Week 1/W1-Low-Pass-Truncated.png}
        \caption{Screenshot of the low pass filter truncated FT graphical output}
        \label{fig:Low-Pass-Filter-Truncated}
      \end{figure}
    \begin{figure}[H]
        \centering
        \includegraphics[width=0.49\columnwidth]{Figures/Week 1/W1-Low-Pass-Reconstructed.png}
        \caption{Screenshot of the low pass filter reconstructed image output}
        \label{fig:Low-Pass-Filter-Image}
      \end{figure}

    
    \newpage    
    \subsubsection{High Pass Filter}
    Next, a high pass filter was implemented. This filter does the opposite of the previous one and removes frequencies below a cutoff value. \autoref{fig:High-Pass-Filter-code} shows the implementation is similar to the low pass filter. The cutoff value was set to $N/128$ and again sets values to $0$. 
    
    \begin{figure}[H]
        \centering
        \includegraphics[width=.9\columnwidth]{Figures/Week 1/W1-High-Pass-Code.png}
        \caption{Screenshot of FT high pass filter code}
        \label{fig:High-Pass-Filter-code}
    \end{figure}
    

    \autoref{fig:High-Pass-Filter-Truncated} shows the truncated FT and \autoref{fig:High-Pass-Filter-Image} shows the final image.
      \begin{figure}[H]
        \centering
        \includegraphics[width=0.49\columnwidth]{Figures/Week 1/W1-High-Pass-Truncated.png}
        \caption{Screenshot of the high pass filter truncated FT graphical output}
        \label{fig:High-Pass-Filter-Truncated}
      \end{figure}

      \begin{figure}[H]
        \centering
        \includegraphics[width=0.49\columnwidth]{Figures/Week 1/W1-High-Pass-Reconstructed.png}
        \caption{Screenshot of the high pass filter reconstructed image output}
        \label{fig:High-Pass-Filter-Image}
      \end{figure}

      \subsubsection{Combined Filters}
      Finally, \autoref{fig:Combined-Filters} shows both filters combined. This has caused some detail in the image to be lost and the visible noise to be reduced, however, new artefacts have been produced.
        \begin{figure}[H] 
            \centering
            \includegraphics[width=0.8\columnwidth]{Figures/Week 1/W1-Both-Filters.png}
            \caption{Screenshot of the graphical output when filters are combined}
            \label{fig:Combined-Filters}
        \end{figure}



\newpage
\section{Lab 2 - Fast Fourier Transform}
This week, a Fast Fourier Transform (FFT) was implemented and benchmarked against the previous FT implementation. 

The time complexity for the original FT is $O(N^2)$, and the time complexity for the FFT is $O(N log N)$, this is a massive speedup. 
This is achieved by taking advantage of symmetries which occur in the calculation, reducing the total number of calculations required. These symmetries, or twiddle factors, are coefficients which reoccur on every even or every odd index. It is by reusing the calculated twiddle factors that allow the FT to be completed in less time. This is the approach taken in the  Cooleyâ€“Tukey FFT algorithm using recursion to divide the problem.

\subsection{2D FFT Implementation}

Java support classes 'FFT.java' and 'FFTImageFiltering.java' was provided. The first class contains code to perform a one-dimensional FFT and its inverse, the latter is a skeleton program to code in. 

To implement a 2D FFT using the fft1d method from the 'FFT' class, a helper function was implemented to transpose the 2D arrays. This is shown in \autoref{fig:transpose-code}. 

    \begin{figure}[H] 
        \centering
        \includegraphics[width=0.8\columnwidth]{Figures/Week 2/Transpose Implementation.png}
        \caption{Screenshot of Java code showing the transpose implementation}
        \label{fig:transpose-code}
    \end{figure}

\autoref{fig:2dFFT-code} shows the implementation of 2D-FFT from the 1D-FFT, a loop iterates over the input arrays 'CRe' and 'CIm', performing an FFT on each row before transposing both arrays and repeating once again. This ensures that the FFT is applied to both axes of the input arrays.

    \begin{figure}[H] 
        \centering
        \includegraphics[width=0.8\columnwidth]{Figures/Week 2/2dFFT Implementation.png}
        \caption{Screenshot of Java code showing the 2D FFT function implementation}
        \label{fig:2dFFT-code}
    \end{figure}

\subsection{Benchmarking}


Benchmarking code was added to the FT and FFT programs to compare run times. Each program from Lab 1 had its 'System.out.println' removed to allow for more accurate results, as the method has a large overhead when called. \autoref{fig:bench-code-start} and \autoref{fig:bench-code-end} show the benchmarking code implementation and \autoref{fig:SimpleFT-Bench} shows the console output when run.


    \begin{figure}[H] 
        \centering
        \includegraphics[width=0.8\columnwidth]{Figures/Week 2/Bench code Start.png}
        \caption{Screenshot of Java Benchmarking code at start of main}
        \label{fig:bench-code-start}
    \end{figure}
    \begin{figure}[H] 
        \centering
        \includegraphics[width=0.8\columnwidth]{Figures/Week 2/Bench code end.png}
        \caption{Screenshot of Java Benchmarking code at end of main}
        \label{fig:bench-code-end}
    \end{figure}
    \begin{figure}[H] 
        \centering
        \includegraphics[width=0.8\columnwidth]{Figures/Week 2/SimpleFT Bench.png}
        \caption{Screenshot of the Console output from SimpleFT Benchmarking code}
        \label{fig:SimpleFT-Bench}
    \end{figure}

    Four programs were run 3 times each, these include two versions of the both naive-FT and FFT - one with no filtering operations and one with a high and low pass filter implemented. The results from the benchmarking is shown in \autoref{tab:W2-bench-results-table}. 
    \begin{table}[htbp]
      \centering
      \resizebox{1\columnwidth}{!}{\begin{tabular}{|c|c|c|c|c|}
         \hline
        \textbf{Run Number} & \textbf{SimpleFT (ms)} & \textbf{SimpleFT With Filters (ms)} & \textbf{Fast FT (ms)} & \textbf{Fast FT With filters (ms)}\\
        \hline
        Run 1 & 333023 & 673758 & 816 & 789\\
        \hline
        Run 2 & 315853 & 590674 & 600 & 971\\
        \hline
        Run 3 & 297395 & 524380 & 668 & 954\\
        \hline
        Mean Average & 315424 & 596271 & 695 & 905\\
        \hline
      \end{tabular}}
      \caption{Lab 2 FFT Benchmarking Results}
      \label{tab:W2-bench-results-table}
    \end{table}
    
    \begin{figure}[H] 
        \centering
        \includegraphics[width=0.8\columnwidth]{Figures/Week 2/FT vs FFT Bench marking.png}
        \caption{Screenshot of FFT vs FT benchmark results graph}
        \label{fig:W2-Benchmarking-Graph}
    \end{figure}

    In all cases, the FFT outperformed the FT by a large margin. This is illustrated in \autoref{fig:W2-Benchmarking-Graph}, showing that the FFT program has a much fastetr run time than the previous implementation, this remained true for all runs of the programs. Please note, the graph's vertical scale is logarithmic to allow for the short run times to be visible.
    
    The mean average of the three runs is used in the following calculations. The FFT program with no filtering allowed for a speedup of  $315424 / 695 = 53.85$.The programs with filtering allowed for a speedup of $596271 / 905 = 658.86$. In both cases, the programs ran much faster when using the FFT implementation, caused by the efficient divide-and-conquer approach method used by the FFT causes the relatively low time complexity.

    Overall the FFT is a far better approach than the naive implementation as it can perform an FT in a fraction of the time.
    
\newpage
\section{Lab 3 - CT Scanner}

This lab explores the computations required for a CT scanner, an FT and filtering is applied to a sinogram to recover visual data. A Radon Transform (RT) (\textcite{4307775} was implemented to calculate the densities for the back-projected sinogram. 

An RT is similar to an FT, however, it produces a set of line integrals or projections which capture the distribution of linear structures within the image. An RT takes two parameters angle '$\theta$' and offset 'r', where '$\theta$' is the orientation angle of the detector assembly and 'r' is the offset of a single detector to the assembly. The transform differs from an FT as it outputs a set of line integrals that capture the distribution of linear structures within the image, rather than frequency information.

Two classes were supplied, 'DisplaySinogramFT.java' rendered the Sinogram-FT as an image and 'Sinogram.java' contains a skeleton program which includes the initial body slice model. It outputs the initial model and calculated sinogram before outputting a back-projected sinogram. The back-projected image contains very little detail, this is shown on the right side of \autoref{fig:W3-initial-output}. The back-projected sinogram image is simply and inverse RT.

The initial source model is the 'Shepp Logan Phantom' \textcite{6499235}, which is made of a series of ellipses representing different densities. The code performs an RT on the model densities to produce the Sinogram, the inversion of this transform will produce the final image. 


\begin{figure}[H] 
    \centering
    \includegraphics[width=0.9\columnwidth]{Figures/Week 3/initial-graphics.png}
    \caption{Screenshot of the graphical output of the initial Sinogram.java}
    \label{fig:W3-initial-output}
\end{figure}


\subsection{Applying an FFT}
Filtering the sinogram is required to make details more visible in the back-projected image. In order to perform filtering, a complex FFT is performed over \(\theta\) on the sinogram, the graphical output of this FFT is shown in \autoref{fig:W3-initial-FT}. Implementation code is shown in \autoref{fig:W3-initial-FT-code}.

\begin{figure}[H] 
    \centering
    \includegraphics[width=0.49\columnwidth]{Figures/Week 3/initial-FFTpng.png}
    \caption{Screenshot of the graphical output of the initial Sinogram Fourier Transform}
    \label{fig:W3-initial-FT}
\end{figure}
\begin{figure}[H] 
    \centering
    \includegraphics[width=0.9\columnwidth]{Figures/Week 3/initial-FFT-code.png}
    \caption{Screenshot of the code performing the Sinogram Fourier Transform}
    \label{fig:W3-initial-FT-code}
\end{figure}




\subsection{Applying a Simple Ramp Filter}
Next, the filter must be applied to the Fourier Transform data. A simple Ramp filter has been implemented. A ramp filter is a type of high-pass filter which reduces low frequencies to decrease blurring. The code is shown in \autoref{fig:W3-ramp-code}. For each element, the code generates a $|K|$ value which is then multiplied by both the real and imaginary numerical components of the Fourier Transform.

The value of 'kSigned' is set to 'iK' if the value is $iK <= N/2$, otherwise, the value is set to $iK-N$.

\begin{figure}[H] 
    \centering
    \includegraphics[width=0.9\columnwidth]{Figures/Week 3/ramp-filter-code.png}
    \caption{Screenshot of the code performing the Ramp filter}
    \label{fig:W3-ramp-code}
\end{figure}

The next step is to rebuild the Sinogram by performing an inverse Fourier Transform over \(\theta\), code is shown in \autoref{fig:W3-inverse-code}.

\begin{figure}[H] 
    \centering
    \includegraphics[width=0.9\columnwidth]{Figures/Week 3/inverse-FT.png}
    \caption{Screenshot of the code performing Inverse FT }
    \label{fig:W3-inverse-code}
\end{figure}

The filtered sinogram is shown in \autoref{fig:W3-filtered-sin}.
\begin{figure}[H] 
    \centering
    \includegraphics[width=0.9\columnwidth]{Figures/Week 3/filtered-sinorgram.png}
    \caption{Screenshot of the graphical output for the filtered sinogram}
    \label{fig:W3-filtered-sin}
\end{figure}

To output the filtered back-projected image, a back-projection operation is performed on the sinogram before the values are normalised. The new image is then drawn. This is shown in \autoref{fig:W3-filtered-back-image}. More detail is visible in the back-projected image, however, a lot of noise has been introduced. To reduce this noise, further filtering is required.
    
\begin{figure}[H] 
    \centering
    \includegraphics[width=1\columnwidth]{Figures/Week 3/filtered-back-projection.png}
    \caption{Screenshot the filtered back-projected sinogram}
    \label{fig:W3-filtered-back-image}
\end{figure}


\subsection{Applying a Ramp Filter with Cutoffs}
The previous filter was altered to make use of a cutoff value, an integer variable 'CUTOFF' was created. This stores the value of: '$N / Value$'. If the '$|K|$' value is greater than this CutOff, the Fourier Component is set to '0'. The code for this implementation is shown in \autoref{fig:W3-filter-with-cutoff-code}.

\begin{figure}[H] 
    \centering
    \includegraphics[width=1\columnwidth]{Figures/Week 3/Filter-with-cuttoff-code.png}
    \caption{Screenshot of the Java code performing filtering with cutoff value}
    \label{fig:W3-filter-with-cutoff-code}
\end{figure}


The program was run with $N/4$ and $N/16$, the back-projected images do have slightly reduced noise. \autoref{fig:W3-many-filters} shows the back-projected images made using a Ramp filter with no CUTOFF (left), with CUTOFF=N/4 (centre) and CUTOFF=N/16 (right).  



\begin{figure}[H] 
    \centering
    \includegraphics[width=1\columnwidth]{Figures/Week 3/filtered-images-ramp-N-4-N-16.png}
    \caption{Screenshot of back project images with filters applied}
    \label{fig:W3-many-filters}
\end{figure}


\newpage
\subsection{Applying Low Pass Cosine Filter}

Next, a low-pass Cosine Filter was applied. The filter takes a similar approach to the previous high-pass filter but applies the following equation. \(|K|  cos(\pi K /(2  *  CUTOFF))\).

Implementation is shown in \autoref{fig:W3-cos-filter-code}. 

\begin{figure}[H] 
    \centering
    \includegraphics[width=1\columnwidth]{Figures/Week 3/filter-cos-codfe.png}
    \caption{Screenshot of the cosine filter code}
    \label{fig:W3-cos-filter-code}
\end{figure}

\autoref{fig:W3-cos-filter-image} shows the image when CUTOFF=$N/4$. The image has little noise removed,
\autoref{fig:W3-cos-filter-image-n-8} shows the image when CUTOFF=$N/8$, the image is now missing a lot of detail compared to the results of the standard ramp filter. 
\begin{figure}[H] 
    \centering
    \includegraphics[width=0.49\columnwidth]{Figures/Week 3/filter-cos-image.png}
    \caption{Screenshot of the cosine filter image Cutoff=N/4}
    \label{fig:W3-cos-filter-image}
\end{figure}
\begin{figure}[H] 
    \centering
    \includegraphics[width=0.49\columnwidth]{Figures/Week 3/filter-cos-image-N-8.png}
    \caption{Screenshot of the cosine filter image Cutoff=N/8}
    \label{fig:W3-cos-filter-image-n-8}
\end{figure}


\newpage
\section{Lab 4 - Radio Interferometry}

Radio Interferometry is a technique used in Astrophotography which makes use of multiple radio telescopes spread over a large area to gather data. The data is then processed afterwards to produce an image.

These are sometimes referred to as software telescopes, as they require a great deal of processing to combine signals to produce an image. To produce an image, two or more signals are combined constructively or destructively (depending on their relative phase). These telescopes are spread over a large distance and connected through an interferometric array \textcite{Borcea_2005}, radiowaves emitted by celestial objects are detected and stored for later processing. To 'aim' at an object, time delays are inserted into all the signals causing signals from a single direction to be in phase with each other.

Visibilities must be calculated to produce an image, visibility is a correlation function between signals arriving in two receivers. To calculate the visibility, the signals are first multiplied together and averaged over a fixed amount of time. This allows the cosine correlator $Rc$ to be obtained. Then a 90\textdegree phase shift is introduced to a single signal, the signals are multiplied and averaged over time to obtain the Sine correlator $Rs$.

Finally, the visibility between the antennas is $V =Rc - iRs$

The sky intensity is the amount of radiowaves received from a particular direction in the sky. If $l, m$ are direction cosines relating to a position in the sky from a fixed origin, then the sky intensity function of position can be denoted as $I(l,m)$.

If $(u, v)$ are the displacement of two telescopes, then the sky intensity can be calculated using the van Cittert-Zernike \autoref{eq:van-Cittert-Zernike}, this is an FT.

\begin{equation}
V(u, v) \propto \sum_{l} \sum_{m} I(l, m) \cdot e^{-2\pi i(ul + vm)}
\label{eq:van-Cittert-Zernike}
\end{equation}

To recover the image we perform an inverse FT 

\begin{equation}
I(l, m) \propto \sum_{u=-\infty}^{+\infty} \sum_{v=-\infty}^{+\infty} V(u, v) \cdot e^{2\pi i(ul + vm)}
\label{eq:van-Cittert-Zernike-inverse}
\end{equation}

This process can be used to create a 'dirty image', in industry, extra processing would be performed on the data to improve the image quality and accuracy. To gather extra data points, multiple telescopes are used in addition to sampling the sky at different times when the telescopes are in a different position (because of the planet's rotation).

A class 'Imaging.java' was provided, it processes a LOFAR data set to produce a point map and an image. \autoref{fig:W4-spiral-being-made} shows points being plotted as the program ran, on the left is at the beginning, a swirl can be seen  as time goes on. Once the program loop has run, \autoref{fig:W4-image-final-swirl} is drawn. It shows the swirls calculated, \autoref{fig:W4-grey-scale} shows a greyscale image of this.  


\begin{figure}[H] 
    \centering
    \includegraphics[width=0.49\columnwidth]{Figures/Week 4/spiral being made.png}
    \caption{Screenshot of the graphical output from Imaging.java }
    \label{fig:W4-spiral-being-made}
\end{figure}
\begin{figure}[H] 
    \centering
    \includegraphics[width=0.49\columnwidth]{Figures/Week 4/Grey-scale-img.png}
    \caption{Screenshot of the greyscale graphical output Imaging.java}
    \label{fig:W4-grey-scale}
\end{figure}

\begin{figure}[H] 
    \centering
    \includegraphics[width=0.49\columnwidth]{Figures/Week 4/Final swirls img.png}
    \caption{Screenshot of the final graphical output of Imaging.java}
    \label{fig:W4-image-final-swirl}
\end{figure}

\newpage
\section{Lab 5 Lattice gas models}
Lattice gas models (LGM) are explored in this lab. An LGM is a cellular automation used to simulate fluid dynamics on a lattice grid.



\subsection{HPP}
A basic Hard-Particle Packing (HPP) model was implemented, each cell on the lattice contains a state of a particle which represents one of four directions the particle is travelling in.

There are two steps in the HPP model which are run in a loop. In each iteration, the 'streaming' step simply moves a particle one cell in the direction it has inertia in (defined by its state) and the 'collision' step updates the particle state if there is a collision. In a collision, each particle's direction is set to be perpendicular to its previous direction. Each iteration represents one 'step' in time

A skeleton program called 'HPP.java' was provided. The implementation of the streaming and collision step is shown in \autoref{fig:W5-streaming-code} and \autoref{fig:W5-collision-step-code} respectively.


\begin{figure}[H] 
    \centering
    \includegraphics[width=0.59\columnwidth]{Figures/Week 5/HPP Streaming Step code.png}
    \caption{Screenshot of the HPP Streaming step code}
    \label{fig:W5-streaming-code}
\end{figure}

\begin{figure}[H] 
    \centering
    \includegraphics[width=0.59\columnwidth]{Figures/Week 5/HPP Collision Step code.png}
    \caption{Screenshot of the HPP Collision step code}
    \label{fig:W5-collision-step-code}
\end{figure}

The code was tested to ensure collisions were working using two particles in both axis directions. \autoref{fig:W5-hpp-before} and \autoref{fig:W5-hpp-after} show multiple particles before and after collision respectively.


\begin{figure}[H] 
    \centering
    \includegraphics[width=0.49\columnwidth]{Figures/Week 5/HPP Mega Collision before.png}
    \caption{Screenshot of HPP model before particle collision}
    \label{fig:W5-hpp-before}
\end{figure}


\begin{figure}[H] 
    \centering
    \includegraphics[width=0.49\columnwidth]{Figures/Week 5/HPP Mega Collision After.png}
    \caption{Screenshot of HPP model after particle collision}
    \label{fig:W5-hpp-after}
\end{figure}
%
%
%\begin{figure}[H] 
%    \centering
%    \includegraphics[width=0.49\columnwidth]{Figures/Week 5/}
%    \caption{Screenshot of the }
%    \label{fig:W5}
%\end{figure}

\subsection{FHP}

\begin{figure}[H] 
    \centering
    \includegraphics[width=0.9\columnwidth]{Figures/Week 5/FHP Initial Run .png}
    \caption{Screenshot of the initial FHP graphical output}
    \label{fig:W5-fhp-initial}
\end{figure}
\subsection{FPP Colour}
\subsection{FPP Large Lattice}





\newpage
\section{Lab 6 - Excitable Media} 
\newpage
\subsection{3 State CA}
This lab consisted of simulating excitable media using cellular automata (CA). To begin, a three-state CA was used to simulate waves. The initial spiral wave output is shown in figure \autoref{fig:W6-initial-3CA}.

\begin{figure}[H] 
    \centering
    \includegraphics[width=0.49\columnwidth]{Figures/Week 6/3stateCA-Initial.png}
    \caption{Screenshot of the graphical output of the initial 3-state CA}
    \label{fig:W6-initial-3CA}
\end{figure}

The Java code was altered to allow for a plane wave simulation. To achieve this, the nested for loop which breaks the initial wave was removed. To allow the wave to repeat itself, the state of all indices on the bottom half of the 'state' matrix was set to '0'. the code and output of the program are shown in Figures \ref{fig:W6-3CA-plane-code} and \ref{fig:W6-3CA-plane-output}. 


\begin{figure}[H] 
    \centering
    \includegraphics[width=0.49\columnwidth]{Figures/Week 6/3stateCA-plane-code.png}
    \caption{Screenshot of the Java code to produce a plane wave}
    \label{fig:W6-3CA-plane-code}
\end{figure}

\begin{figure}[H] 
    \centering
    \includegraphics[width=0.49\columnwidth]{Figures/Week 6/3stateCA-plane-output.png}
    \caption{Screenshot of the graphical output of a plane wave using 3-state CA}
    \label{fig:W6-3CA-plane-output}
\end{figure}



For different simulation starting locations, conditional branching was implemented to allow the user to set the starting location and wave type via a variable in the program. A variable called 'startLocation' must be set to '1', '2' or'3' to define the starting location. \autoref{fig:W6-3CA-conditional-logic-code} shows the code implementing this.

A similar approach was created to allow the user to define the 'doSpiralWave' variable, allowing the wave type to be altered.

\begin{figure}[H] 
    \centering
    \includegraphics[width=0.6\columnwidth]{Figures/Week 6/3stateCA-plane-logic-code.png}
    \caption{Screenshot of the code controlling simulation start-location logic}
    \label{fig:W6-3CA-conditional-logic-code}
\end{figure}

\newpage

\autoref{fig:W6-3CA-start-corner} shows the graphical output when 'startLocation=3', starting the simulation in the corner of the grid. It sets all the 'state' array values to '0', with the exception of a small box of excited cells in one corner.

\begin{figure}[H] 
    \centering
    \includegraphics[width=0.49\columnwidth]{Figures/Week 6/3stateCA-CORNER-output.png}
    \caption{Screenshot of 3-State CA simulation starting in the corner of the grid}
    \label{fig:W6-3CA-start-corner}
\end{figure}

\autoref{fig:W6-3CA-start-middle} shows the graphical output when 'startLocation=2', starting the simulation in the middle of the grid by setting . 
\begin{figure}[H] 
    \centering
    \includegraphics[width=0.49\columnwidth]{Figures/Week 6/3stateCA-MIDDLE-output.png}
    \caption{Screenshot of 3-State CA simulation starting in the middle of the grid}
    \label{fig:W6-3CA-start-middle}
\end{figure}
\newpage
\subsection{GST}
Next, a Gerhardt-Schuster-Tyson model was implemented to create a spiral and plane wave. The highlighted nested for loop shown in \autoref{fig:W6-GST-plane-code} was removed to create a plane wave simulation. \autoref{fig:W6-GST-side-by-side-output} shows both spiral (left side) and plane wave (right side) simulation outputs.

\begin{figure}[H] 
    \centering
    \includegraphics[width=0.49\columnwidth]{Figures/Week 6/GST-plane-code.png}
    \caption{Screenshot of the GST plane wave code alteration}
    \label{fig:W6-GST-plane-code}
\end{figure}

\begin{figure}[H] 
    \centering
    \includegraphics[width=0.49\columnwidth]{Figures/Week 6/GST-side-by-side-output.png}
    \caption{Screenshot of the graphical output of GST spiral (left) and plane (right) wave simulations}
    \label{fig:W6-GST-side-by-side-output}
\end{figure}


Changing the value of some parameters alters the wave shape, size and stability. For instance, increasing the value of 'K0\_EXCI' to '10' decreases cell excitability. This causes the wave formation to look square, rather than circular, in addition to reducing the width of the wave and slowing the wave propagation speed. This is shown in \autoref{fig:W6-GST-less-excitable}.

\begin{figure}[H] 
    \centering
    \includegraphics[width=0.49\columnwidth]{Figures/Week 6/gst-square.png}
    \caption{Screenshot of the graphical output of GST when cell excitability is reduced}
    \label{fig:W6-GST-less-excitable}
\end{figure}


Altering the 'K0\_RECO' sets the minimum number of unexcited neighbours to set a cell's state to recovery. Increasing the value causes more cells to remain excited after each wave has passed, these cells usually appear near the edges of the matrix, introducing 'noise' into the system. \autoref{fig:W6-GST-high-min-neighbours} shows these pixels at the edges of the grid.


Inversely, reducing this value decreases the number of cells left excited after a wave has passed, seen in \autoref{fig:W6-GST-low-min-neighbours}.
\begin{figure}[H] 
    \centering
    \includegraphics[width=0.49\columnwidth]{Figures/Week 6/GST-high-min-neighbours.png}
    \caption{Screenshot of the graphical output of GST when K0\_RECO is high}
    \label{fig:W6-GST-high-min-neighbours}
\end{figure}

\begin{figure}[H] 
    \centering
    \includegraphics[width=0.49\columnwidth]{Figures/Week 6/GST-low-min-neighbours.png}
    \caption{Screenshot of the graphical output of GST when K0\_RECO is low}
    \label{fig:W6-GST-low-min-neighbours}
\end{figure}

The neighbourhood radius correlates with the width of the wave, increasing this value causes the wave to be thicker \autoref{fig:W6-GST-high-radius}. The origin of the spiral become lower on the grid with higher values.

\begin{figure}[H] 
    \centering
    \includegraphics[width=0.49\columnwidth]{Figures/Week 6/GST-Large-Radius.png}
    \caption{Screenshot of the graphical output of GST when 'R' - radius is increased}
    \label{fig:W6-GST-high-radius}
\end{figure}
\newpage
\subsection{4 State CA}
The initial three-state CA was built upon to add another excited state, state '3' now represents the front of a wave. In addition to the extra state, another array timeToStateChange was created to store the time value until a state may change. \autoref{fig:W6-4CA-dec} shows the variable declaration, \autoref{fig:W6-4CA-init} shows the arrays' value initiation.


\begin{figure}[H] 
    \centering
    \includegraphics[width=1\columnwidth]{Figures/Week 6/4stateCA-time-delaration.png}
    \caption{Screenshot of the 'timeToStateChange' declaration code}
    \label{fig:W6-4CA-dec}
\end{figure}

\begin{figure}[H] 
    \centering
    \includegraphics[width=1\columnwidth]{Figures/Week 6/4stateCA-time-values-init.png}
    \caption{Screenshot of the 'timeToStateChange' initiation code}
    \label{fig:W6-4CA-init}
\end{figure}


The timeToStateChange stores an integer between 0 and 3. In each iteration, all time values are decremented towards 0. This value is updated each state change to the corresponding value in \autoref{tab:state-time-values}.

\begin{table}[htbp]
  \centering
  \renewcommand{\arraystretch}{1.2}
  \begin{tabular}{|c|c|}
    \hline
    \textbf{state} & \textbf{timeToStateChange} \\

    \hline
    1 & 3 \\
    \hline
    2 & 3 \\
    \hline
    3 & 2 \\
    \hline
  \end{tabular}
  \caption{timeToStateChange value when a cell transitions into each state}
  \label{tab:state-time-values}
\end{table}


The program must search for excited neighbours. The neighbour radius has been increased by four to eight neighbours, meaning cells which are diagonally adjacent to the origin cells are included in the search. \autoref{fig:W6-4CA-search-code} Shows that two comparisons are made on each of these cell - setting excitedNeighbour to true, if either a '2' or '3' is found in any of the eight cells. 
\begin{figure}[H] 
    \centering
    \includegraphics[width=1\columnwidth]{Figures/Week 6/4stateCA-neighbour-search-code.png}
    \caption{Screenshot of 'fourStateCA' code searching for excited neighbours}
    \label{fig:W6-4CA-search-code}
\end{figure}

In each iteration, the program must update each 'state' and 'timeToStateChange' value. The first conditional statement, shown in \autoref{fig:W6-4CA-search-code}, decrements the 'timeToStateChange' by one. 

After this the switch statement updates the 'state' and 'timeToStateChange' values dependant on if the cell has excited neighbours or not, and if timeToStateChange is 0.  

\begin{figure}[H] 
    \centering
    \includegraphics[width=1\columnwidth]{Figures/Week 6/4stateCA-update-code.png}
    \caption{Screenshot of fourStateCA Code updating 'state' and 'timeToStateChange' arrays}
    \label{fig:W6-4CA-update-code}
\end{figure}


\autoref{fig:W6-4CA-colour-code} shows an additional colouring condition has been added, allowing a different colour for the new state=3, the colouring scheme is outlined in \autoref{tab:state-color-values}.  

\begin{figure}[H] 
    \centering
    \includegraphics[width=1\columnwidth]{Figures/Week 6/4stateCA-color-code.png}
    \caption{Screenshot of fourStateCA cell colouring code}
    \label{fig:W6-4CA-colour-code}
\end{figure}

\vspace{10mm}
\begin{table}[htbp]
  \centering
  \begin{tabular}{|c|c|c|}
    \hline
    \textbf{State Number} &\textbf{State Meaning} & \textbf{Cell Colour} \\

    \hline
    0 & Resting & Background (White)\\
    \hline
    1 & Recovering & Blue \\
    \hline
    2 & Excited-Wave-Plateau & Dark Red \\
    \hline
    3 & Excited-Wave-Front & Bright Red \\
    \hline
  \end{tabular}
  \caption{'fourStateCA' Cell Colour Scheme}
  \label{tab:state-color-values}
\end{table}

The graphical output for the program is shown in \autoref{fig:W6-4CA-output}.
\begin{figure}[H] 
    \centering
    \includegraphics[width=0.49\columnwidth]{Figures/Week 6/4stateCA-output.png}
    \caption{Screenshot of 'fourStateCA' graphical output}
    \label{fig:W6-4CA-output}
\end{figure}
\newpage
\section{Lab 7}
\newpage
\section{Lab 8}
\newpage
\section{Lab 10}

